{"version":3,"sources":["webpack:///webpack/bootstrap 49b21103a210fb187a95","webpack:///./app/scripts/vinylsiding.js","webpack:///./app/scripts/utility.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4EAA4E,SAAS;AACrF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;AC5HA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,YAAY;AAC3B,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA","file":"vinylsiding_0.0.2.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 49b21103a210fb187a95","'use strict';\n\nimport Utility from './utility';\n/**\n ** @file Vinylsiding Class\n ** Wire up common webpage elements.\n ** Make useful utility functions available as early as possible.\n */\nfunction Vinylsiding() {\n    this.util = Utility;\n    window.onload = function () {\n        Vinylsiding.prototype.setDynamicHeights();\n        Vinylsiding.prototype.secureTargetBlank();\n        // Vinylsiding.prototype.modal.attachBodyListener();\n        // Vinylsiding.prototype.modal.addOverlayToDOM();\n        Vinylsiding.prototype.lazyLoad();\n    };\n    this.modules = {};\n}\n\nVinylsiding.prototype.addModule = function(module_name, module) {\n    this.modules[module_name] = module;\n    if (typeof(module.beforeLoad) == 'function') {\n        module.beforeLoad(this);\n    }\n    return true;\n};\n\nVinylsiding.prototype.callModule = function (module_name, method_name, args) {\n    if (!this.modules.hasOwnProperty(module_name)) {\n        throw new Error('');\n    }\n\n    if (!this.modules[module_name].hasOwnProperty(method_name)) {\n        throw new Error('');\n    }\n\n    if (typeof(this.modules[module_name][method_name]) != 'function') {\n        throw new Error('');\n    }\n\n    return this.modules[module_name][method_name](args);\n};\n\n// add rel attr to _blank links to help mitigate tabnabbing\nVinylsiding.prototype.secureTargetBlank = function () {\n    var elements = document.querySelectorAll('a[target=\"_blank\"]');\n\n    if (!elements || !elements.length) {\n        return;\n    }\n\n    for (var i = 0, len = elements.length; i < len; i++) {\n        elements[i].setAttribute('rel', 'noopener noreferrer');\n    }\n};\n\n// set the style height of an elem to that of it's referenced element.\n// selects elements with heightSelector class by default.\n// data-height-ref is either the id of the reference elem or empty.\n// empty data-height-ref will explicitly set an elements height to its own\n// current height.\nVinylsiding.prototype.setDynamicHeights = function () {\n    var elements = document.querySelectorAll('.set-height');\n\n    if (!elements || !elements.length) {\n        return false;\n    }\n\n    for (var i = 0, len = elements.length, reference, foundReferenceElement; i < len; i++) {\n        reference = elements[i].getAttribute('data-height-ref');\n\n        // if no reference found, we use the given element and set its height explicitly.\n        foundReferenceElement = (!reference) ? elements[i] : document.querySelector('#' + reference);\n\n        if (!foundReferenceElement) {\n            continue;\n        }\n        this.util.setHeightOnElement(elements[i], foundReferenceElement);\n    }\n};\n\n// todo - here http://codepen.io/jmperez/pen/yYjPER\n\n/**\n * Lazy load images in a graceful manner.\n */\nVinylsiding.prototype.lazyLoad = function () {\n    var lazyLoaders = document.querySelectorAll('.vinyl-lazyloader');\n    if (!lazyLoaders.length) {\n        return;\n    }\n    for (var i = 0, len = lazyLoaders.length; i < len; i++) {\n        lazyLoadImage(lazyLoaders[i]);\n    }\n};\n\nfunction lazyLoadImage(container) {\n    var previewImage = container.querySelector('.base-image'),\n        smallImage = new Image(),\n        largeImage = new Image();\n    // 1: load small image and show it\n    smallImage.onload = function () {\n        Vinylsiding.util.removeClass(previewImage, 'blurry');\n    };\n    smallImage.src = previewImage.src;\n\n    // 2: load large image\n    largeImage.className = 'loading';\n    largeImage.onload = function () {\n        Vinylsiding.util.removeClass(largeImage, 'loading');\n    };\n    largeImage.src = previewImage.dataset.vimageLarge;\n\n    container.appendChild(largeImage);\n}\n\nvar define = define || false;\nif (define) {\n    define('Vinylsiding',\n    [\"Utility\"],\n    function (Utility) {\n        return new Vinylsiding(Utility);\n    });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/scripts/vinylsiding.js\n// module id = 0\n// module chunks = 0","/**\n ** Commonly needed stateless utility functions.\n */\n\nclass Utility {\n\n    /**\n     * Check if image failed to load.\n     * @param  {Element} img - An <img> node.\n     * @return {Boolean} True if image is loaded, otherwise false.\n     */\n    static isImageOk(img) {\n        // adapted from https://stereochro.me/ideas/detecting-broken-images-js\n        if (!img.complete ||\n            (typeof img.naturalWidth !== 'undefined' &&\n                img.naturalWidth === 0)) {\n            return false;\n        }\n        return true;\n    }\n\n\n    /**\n     * Match elemClass against element's classes.\n     * @param  {Element} element - DOM element.\n     * @param  {String} elemClass - Class name to match. Can include leading '.'\n     * @return {Boolean} True if element has class, otherwise false.\n     */\n    static hasClass(element, elemClass) {\n        // remove any leading . for convenience.\n        if (elemClass.charAt(0) === '.') {\n            elemClass = elemClass.substr(1);\n        }\n\n        if (typeof element.className !== 'string') {\n            return false;\n        }\n\n        if (element.className === elemClass) {\n            return true;\n        }\n\n        if (!element.className.match(elemClass)) {\n            return false;\n        }\n\n        var classes = element.className.split(' ');\n\n        if (!classes || !classes.length) {\n            return false;\n        }\n\n        for (var i = 0, len = classes.length; i < len; i++) {\n            if (classes[i] === elemClass) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Add elemClass to element's class list.\n     * @param  {Element} element - DOM element.\n     * @param  {String} elemClass - Class to add to element.\n     * @return {Boolean} True on success, otherwise false.\n     */\n    static addClass(element, elemClass) {\n        if (typeof element.className === 'undefined') {\n            return false;\n        }\n\n        if (this.hasClass(element, elemClass)) {\n            return true;\n        }\n\n        element.className = element.className + ' ' + elemClass;\n\n        return true;\n    }\n\n    /**\n     * Sets height of element to that of referencedElement.\n     * @param  {Element} element - DOM element whose height will be set.\n     * @param  {Element} referencedElement - DOM element whose height will be read.\n     * @return {Boolean} Always returns true.\n     */\n    static setHeightOnElement(element, referencedElement) {\n        element.style.height = referencedElement.offsetHeight + 'px';\n        return true;\n    }\n\n    /**\n     * Remove elemClass from element's class list.\n     * @param  {Element} element - DOM element.\n     * @param  {String} elemClass - Class to remove from element.\n     * @return {Boolean} True on success, otherwise false.\n     */\n    static removeClass(element, elemClass) {\n        if (typeof element.className === 'undefined') {\n            return false;\n        }\n\n        if (!this.hasClass(element, elemClass)) {\n            return false;\n        }\n\n        var classes = element.className.split(' '),\n            preservedClasses = [];\n\n        for (var i = 0, len = classes.length; i < len; i++) {\n            if (classes[i] !== elemClass) {\n                preservedClasses.push(classes[i]);\n            }\n        }\n        element.className = preservedClasses.join(' ');\n        return true;\n    }\n\n    /**\n     * Ascend the DOM, returning a DOM element with the specified class if found.\n     * @param  {Element} element - DOM element.\n     * @param  {String} elemClass - Class to match.\n     * @param  {Integer} limit - Maximum number of nodes to check\n     * @return {Element} The matched element if found, otherwise false.\n     */\n    static findParentWithClass(element, elemClass, limit) {\n        var found = false,\n            count = 0;\n        if (!limit) {\n            limit = 100;\n        }\n        while (element !== null && !found && count < limit) {\n            if (element.tagName === 'BODY') {\n                // we've gone too far!\n                return false;\n            }\n\n            if (this.hasClass(element, elemClass)) {\n                found = element;\n            } else {\n                element = element.parentNode;\n            }\n\n            count++;\n        }\n        return found;\n    }\n\n    /**\n     * Ascend the DOM, returning the first matched <a> node.\n     * @param  {Element} element - DOM element.\n     * @param  {Integer} limit - Maximum number of nodes to check\n     * @return {Element} The matched element if found, otherwise false.\n     */\n    static findParentLink(element, limit) {\n        var found = false,\n            count = 0;\n        if (!limit) {\n            limit = 100;\n        }\n        while (element !== null && !found && count < limit) {\n            if (element.tagName === 'BODY') {\n                // we've gone too far!\n                return false;\n            }\n            if (element.localName.toLowerCase() === 'a') {\n                found = element;\n            } else {\n                element = element.parentNode;\n            }\n            count++;\n        }\n        return found;\n    }\n\n    /**\n     * Return first child of an element that is an HTML element.\n     * @param  {Element} element - DOM element.\n     * @return {Element} The html element if found, otherwise element.firstChild.\n     */\n    static findFirstChild(element) {\n        var firstChild = element.firstChild;\n        while (firstChild && firstChild.nodeType !== 1) {\n            firstChild = firstChild.nextSibling;\n        }\n        return firstChild;\n    }\n\n    /**\n     * Find the value of the first GET parameter that matches `key`.\n     * @param  {String} key - The get parameter to search for.\n     * @return {String} The value of the supplied GET param, otherwise false.\n     */\n    static getParam(key) {\n        var search = window.location.search.toLowerCase().substring(1),\n            params = [];\n\n        if (search.indexOf('&') <= -1) {\n            params.push(search);\n        } else {\n            params = search.split('&');\n        }\n\n        for (var i = 0, len = params.length, comparisonResult; i < len; i++) {\n            comparisonResult = this.compareKeyValuePair(params[i], key);\n            if (comparisonResult) {\n                return comparisonResult;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check whether a GET param has the given key\n     * @param {string} pair - the get param, format: paramName=paramValue\n     * @param {string} key - the string to match against the parametere name\n     * @returns {Boolean} true if `pair`'s name equals `key`, otherwise false\n     */\n    static compareKeyValuePair(pair, key) {\n        var keyValue = pair.split('=');\n        if (keyValue.length !== 2) {\n            return false;\n        }\n        var decodedKey = decodeURIComponent(keyValue[0]),\n            decodedValue = decodeURIComponent(keyValue[1]);\n\n        if (decodedKey.toString() === key) {\n            return decodedValue;\n        }\n        return false;\n    }\n\n    /**\n     * Scroll the page to the top or bottom of the passed element.\n     * @param {HTMLElement} elem - element to scroll to.\n     * @param {string} [position=top] - top: top of window = top of element.  bottom: bottom of window = bottom of element.\n     */\n    static scrollIntoView(elem, position) {\n        if (!position) {\n            position = 'top';\n        }\n        var currentWindowYOffset = (window.pageYOffset || document.documentElement.scrollTop) -\n            (document.documentElement.clientTop || 0),\n            elementWindowYOffset;\n        switch (position) {\n        case 'bottom':\n            var elemY = this.getPosition(elem).y + currentWindowYOffset,\n                elemHeight = elem.offsetHeight,\n                elemBottomPixel = elemY + elemHeight,\n                extraSpacePixels = 30,\n                windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight,\n                calculatedOffset = elemBottomPixel - windowHeight + extraSpacePixels;\n            elementWindowYOffset = (calculatedOffset >= 0) ? calculatedOffset : 0;\n            break;\n        case 'top':\n            elementWindowYOffset = this.getPosition(elem).y;\n            break;\n        default:\n            throw 'Invalid position.';\n        }\n\n        var initialWindowYOffset = currentWindowYOffset;\n\n        if (initialWindowYOffset === elementWindowYOffset) {\n            return;\n        }\n\n        var interval = window.setInterval(function () {\n            if (currentWindowYOffset !== elementWindowYOffset) {\n                var offset = 1;\n                var distance = Math.abs(currentWindowYOffset - elementWindowYOffset);\n                if (distance < 10) {\n                    offset = distance;\n                } else {\n                    offset += Math.floor(Math.sqrt(distance));\n                }\n\n                if (currentWindowYOffset > elementWindowYOffset) {\n                    currentWindowYOffset -= offset;\n                } else {\n                    currentWindowYOffset += offset;\n                }\n                window.scrollTo(0, currentWindowYOffset);\n            } else {\n                window.clearInterval(interval);\n            }\n        }, 25);\n    }\n\n    /**\n     * Waits for an element to be visible on screen, then executes a callback.\n     * @param {HTMLElement} elemSelector - CSS selector of element to wait to wait for\n     * @param {function} callback\n     */\n    static waitUntilVisible(elemSelector, callback) {\n        var interval = window.setInterval(function () {\n            if (!Utility.checkVisible(document.querySelector(elemSelector))) {\n                return;\n            }\n            window.clearInterval(interval);\n            // once element is in view, call callback.\n            callback();\n        }, 500);\n    }\n\n    /**\n     * Get [x,y] of top left of element.\n     * @credit adapted from http://stackoverflow.com/a/24829409\n     * @param {HTMLElement} element\n     * @returns {Integer[]} [x,y] of element.\n     */\n    static getPosition(element) {\n        var xPosition = 0,\n            yPosition = 0;\n\n        while (element) {\n            xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);\n            yPosition += (element.offsetTop - element.scrollTop + element.clientTop);\n            element = element.offsetParent;\n        }\n\n        return {\n            x: xPosition,\n            y: yPosition\n        };\n    }\n\n    /**\n     * Check if element is on screen\n     * @credit adapted from - http://stackoverflow.com/a/5354536\n     * @param {HTMLElement} element\n     * @returns {Boolean} true if element on screen, otherwise false.\n     */\n    static checkVisible(element) {\n        if (!element) {\n            throw 'Invalid Element';\n        }\n        var rect = element.getBoundingClientRect();\n        var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);\n        return !(rect.bottom < 0 || rect.top - viewHeight >= 0);\n    }\n\n    /**\n     * Check if mouse click occured within coordinates of element.\n     * @param {MouseEvent} mouseEvent\n     * @param {HTMLElement} element\n     */\n    // static isOver = function(mouseEvent, element) {\n    //     var coordinates = this.getMouseCoordinates(mouseEvent);\n    //     console.log(coordinates);\n    // };\n\n    /**\n     * Check if device is likely iOS\n     * @credit adapted from - http://stackoverflow.com/a/9039885\n     * @returns {Boolean}\n     */\n    static iOS() {\n        var iDevices = [\n            'iPad Simulator',\n            'iPhone Simulator',\n            'iPod Simulator',\n            'iPad',\n            'iPhone',\n            'iPod'\n        ];\n        if (navigator.platform) {\n            while (iDevices.length) {\n                if (navigator.platform === iDevices.pop()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check if browser is likely Safari\n     * @returns {Boolean}\n     */\n    static isSafari() {\n        var e = navigator.userAgent.toLowerCase();\n        return e.indexOf('safari') !== -1 && !(e.indexOf('chrome') > -1);\n    }\n\n    /**\n     * Gets the pointer position from an event.\n     * @param {Event} mouseEvent\n     * @return {integer[]} [x,y] of pointer device.\n     */\n    static getMouseCoordinates(mouseEvent) {\n        if ('undefined' !== typeof mouseEvent.pageX &&\n            'undefined' !== typeof mouseEvent.pageY) {\n\n            return [mouseEvent.pageX, mouseEvent.pageY];\n        }\n        if (mouseEvent.touches && mouseEvent.touches.length) {\n            return [mouseEvent.touches[0].pageX, mouseEvent.touches[0].pageY];\n        }\n        throw 'No coordinates in passed event.';\n    }\n\n    /**\n     * Shorthand to add the same callbacks to the same element for multiple events.\n     * Useful for handling redundancy from supporting multiple device types.\n     * @param {string[]} events - array of events\n     * @param {HTMLElement} element - element to which the events are attached.\n     * @param {function} callback\n     * @param {Boolean} [useCapture=false] - @see EventTarget.addEventListener()\n     */\n    static addEvents(events, element, callback, useCapture) {\n        if (typeof useCapture === 'undefined') {\n            useCapture = false;\n        }\n        for (var i = 0, len = events.length; i < len; i++) {\n            element.addEventListener(events[i], callback, useCapture);\n        }\n    }\n\n    /**\n     * If elemClass is a class on element, remove it. otherwise, add it.\n     * @param  {Element} element - DOM element whose class will be toggled.\n     * @param  {String} elemClass - Class to toggle.\n     * @return {Boolean} True on success, otherwise false.\n     */\n    static toggleClass(element, elemClass) {\n        if (!element || !elemClass) {\n            return false;\n        }\n        if (this.hasClass(element, elemClass)) {\n            return this.removeClass(element, elemClass);\n        } else {\n            return this.addClass(element, elemClass);\n        }\n    }\n\n}\n\nmodule.exports = Utility;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/scripts/utility.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}